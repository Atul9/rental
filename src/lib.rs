//! A macro to generate self-borrowing structs, plus a few predefined type
//! aliases for convenience.
//!
//! # Overview
//!
//! It can sometimes occur in the course of designing an API that you find
//! yourself in a situation where you need to store, in a single struct, both
//! an owned value and a borrow of that value. Rust's concept of ownership and
//! borrowing is quite flexible, but can't quite express such a scenario.
//!
//! One example might be `libloading`. That crate provides a `Library` struct
//! that defines methods to borrow `Symbol`s from it. These symbols are bounded
//! by the lifetime of the library, and are thus considered a borrow. Under
//! normal circumstances, one would be unable to store both the library and the
//! symbols within a single struct, but the macro defined in this crate allows
//! you to define a struct that is capable of storing both simultaneously.
//!
//! This crate uses the term "rental" to describe this concept of a borrow that
//! co-exsists with its owner in the same struct. The borrow itself is called
//! the "rented" type. The "owner", naturally, is the item in the struct that
//! owns the borrow.
//!
//! The API consists of the [`rental`](macro.rental.html) macro, which generates
//! rental structs, and a few premade instantiations of this macro handling
//! rented bare references.  If you only need to rent references, see
//! [`RentRef`](struct.RentRef.html) and [`RentMut`](struct.RentMut.html), as
//! well as the associated type aliases for common rental scenarios. The
//! documentation for the [`rental`](macro.rental.html) macro describes the API
//! of the types generated by it. The capabilities of a rental struct cannot be
//! described as a trait without language support for HKT (Higher-Kinded Types),
//! so the rental API is merely a convention with a common pattern.


/// This macro is the bedrock of the API. It allows you to define three 
/// different kinds of items related to renting.
///
/// NOTE: This macro is only necessary to use if you want to define new rental
/// types that can store customized forms of borrow other than a bare reference.
/// For bare references, this crate provides premade types, called
/// [`RentRef`](struct.RentRef.html) and [`RentMut`](struct.RentMut.html), that
/// accomplish this. Several types aliases are also provided for common
/// scenarios.
///
/// The top level item in an invocation of this macro must be a module. This
/// module can have any name you like, may be public or not, and will hold all
/// declared items.
///
/// The first two items this macro can produce are shared and mutable rentals.
/// Both forms are tuple-structs that contain an (owner, rental) pair. Both
/// have a similar API, with minor differences pointed out below. They are
/// declared as follows:
/// 
/// ```rust,ignore
/// // Shared
/// pub rental $rental:ident<'owner $(, $param:tt)*> where [$($clause:tt)*] (
///     $owner_ty:ty,
///     $rental_ty:ty$(,)*
/// );
///
/// // Mutable
/// pub rental $rental:ident<'owner $(, $param:tt)*> where [$($clause:tt)*] (
///     mut $owner_ty:ty,
///     $rental_ty:ty$(,)*
/// );
///
/// ```
///
/// The key difference being the presence of absence of `mut` on the owner
/// declaration. Note that the first generic parameter must be a lifetime
/// called `'owner`. This lifetime has special implications and is very
/// important. It links together the owner and the rented borrow,
///
/// 
#[macro_export]
macro_rules! rental {
	{
		mod $rental_mod:ident {
			$($items:tt)*
		}
	} => {
		mod $rental_mod {
			#![allow(unused_imports)]
			use ::std::ops::{Deref, DerefMut};
			use ::std::ops::Drop;
			use ::std::result::Result;
			use ::std::mem;

			use $crate::{FixedDeref, Rental, RentalMut, RentalDeref, RentalDerefMut, RentalDerefEq};

			rental!{@ITEM $($items)*}
		}
	};
	{
		pub mod $rental_mod:ident {
			$($items:tt)*
		}
	} => {
		pub mod $rental_mod {
			#![allow(unused_imports)]
			use ::std::ops::{Deref, DerefMut};
			use ::std::ops::Drop;
			use ::std::result::Result;
			use ::std::mem;

			use $crate::{FixedDeref, Rental, RentalMut, RentalDeref, RentalDerefMut, RentalDerefEq};

			rental!{@ITEM $($items)*}
		}
	};


	{
		@ITEM pub rental $rental:ident<'owner $(, $param:tt)*> where [$($clause:tt)*] (
			mut $owner_ty:ty,
			$rental_ty:ty$(,)*
		);
		$($rest:tt)*
	} => {
		/// A struct representing an (owner, rental) pair.
		pub struct $rental<'owner $(, $param)*> where
			$owner_ty: FixedDeref + DerefMut, $($clause)*
		{
			owner: Option<$owner_ty>,
			rental: Option<$rental_ty>,
		}


		impl<'rental $(, $param)*> $rental<'rental $(, $param)*> where
			$owner_ty: FixedDeref + DerefMut
		{
			#[allow(dead_code)]
			pub fn new<F__>(mut owner: $owner_ty, f: F__)
				-> $rental<'rental $(, $param)*> where
				F__: for<'owner> FnOnce(&'owner mut <$owner_ty as Deref>::Target) -> $rental_ty
			{
				$rental{
					rental: unsafe {
						Some(mem::transmute(f(&mut *<$owner_ty as DerefMut>::deref_mut(&mut owner))))
					},
					owner: Some(owner),
				}
			}


			#[allow(dead_code)]
			pub fn try_new<E__, F__>(mut owner: $owner_ty, f: F__)
				-> Result<$rental<'rental $(, $param)*>, (E__, $owner_ty)> where
				F__: for<'owner> FnOnce(&'owner mut <$owner_ty as Deref>::Target) -> Result<$rental_ty, E__>
			{
				Ok($rental{
					rental: unsafe {
						let ptr: *mut _ = &mut *<$owner_ty as DerefMut>::deref_mut(&mut owner);
						match f(&mut *ptr) {
							Ok(asset) => Some(mem::transmute(asset)),
							Err(err) => return Err((err, owner)),
						}
					},
					owner: Some(owner),
				})
			}


			#[allow(dead_code)]
			pub fn rent<'s, F__, R__>(&'s self, f: F__) -> R__ where
				F__: for<'owner: 's> FnOnce(&'s $rental_ty) -> R__, R__: 's
			{
				f(self.rental.as_ref().unwrap())
			}


			#[allow(dead_code)]
			pub fn rent_mut<'s, F__, R__>(&'s mut self, f: F__) -> R__ where
				F__: for<'owner: 's> FnOnce(&'s mut $rental_ty) -> R__, R__: 's
			{
				f(self.rental.as_mut().unwrap())
			}
		}


		unsafe impl<'owner $(, $param)*> Rental<'owner> for $rental<'owner $(, $param)*> where
			$owner_ty: FixedDeref + DerefMut,
			$($clause)*
		{
			type Owner = $owner_ty;
			type Rental = $rental_ty;


			#[inline(always)]
			unsafe fn rental(&self) -> &$rental_ty { self.rental.as_ref().unwrap() }
			unsafe fn from_parts(owner: $owner_ty, rent: $rental_ty) -> Self { $rental{owner: Some(owner), rental: Some(rent)} }
			unsafe fn into_parts(mut self) -> ($owner_ty, $rental_ty) { (self.owner.take().unwrap(), self.rental.take().unwrap()) }
			fn into_owner(mut self) -> $owner_ty { self.owner.take().unwrap() }
		}


		unsafe impl<'owner $(, $param)*> RentalMut<'owner> for $rental<'owner $(, $param)*> where
			$owner_ty: FixedDeref + DerefMut,
			$($clause)*
		{
			#[inline(always)]
			unsafe fn rental_mut(&mut self) -> &mut <Self as Rental<'owner>>::Rental { self.rental.as_mut().unwrap() }
		}


		impl<'owner $(, $param)*> Deref for $rental<'owner $(, $param)*> where
			$owner_ty: FixedDeref + DerefMut,
			$rental<'owner $(, $param)*>: RentalDeref<'owner> + for<'rental> RentalDerefEq<'rental, $rental<'rental $(, $param)*>>,
		{
			type Target = <$rental<'owner $(, $param)*> as RentalDeref<'owner>>::Target;

			#[inline(always)]
			fn deref(&self) -> &<$rental<'owner $(, $param)*> as RentalDeref<'owner>>::Target { unsafe { self.rental_target() } }
		}


		impl<'owner $(, $param)*> DerefMut for $rental<'owner $(, $param)*> where
			$owner_ty: FixedDeref + DerefMut,
			$rental<'owner $(, $param)*>: RentalDerefMut<'owner> + for<'rental> RentalDerefEq<'rental, $rental<'rental $(, $param)*>>,
		{
			#[inline(always)]
			fn deref_mut(&mut self) -> &mut <$rental<'owner $(, $param)*> as Deref>::Target { unsafe { self.rental_target_mut() } }
		}


		impl<'rental $(, $param)*> Drop for $rental<'rental $(, $param)*> where
			$owner_ty: FixedDeref + DerefMut,
		{
			fn drop(&mut self) {
				mem::drop(self.rental.take());
				mem::drop(self.owner.take());
			}
		}


		rental!{@ITEM $($rest)*}
	};


	{
		@ITEM pub rental $rental:ident<'owner $(, $param:tt)*> where [$($clause:tt)*] (
			$owner_ty:ty,
			$rental_ty:ty$(,)*
		);
		$($rest:tt)*
	} => {
		pub struct $rental<'owner $(, $param)*> where
			$owner_ty: FixedDeref, $($clause)*
		{
			owner: Option<$owner_ty>,
			rental: Option<$rental_ty>,
		}


		impl<'rental $(, $param)*> $rental<'rental $(, $param)*> where
			$owner_ty: FixedDeref
		{
			#[allow(dead_code)]
			pub fn new<F__>(owner: $owner_ty, f: F__)
				-> $rental<'rental $(, $param)*> where
				F__: for<'owner> FnOnce(&'owner <$owner_ty as Deref>::Target) -> $rental_ty
			{
				$rental{
					rental: unsafe {
						Some(mem::transmute(f(&*<$owner_ty as Deref>::deref(&owner))))
					},
					owner: Some(owner),
				}
			}


			#[allow(dead_code)]
			pub fn try_new<E__, F__>(owner: $owner_ty, f: F__)
				-> Result<$rental<'rental $(, $param)*>, (E__, $owner_ty)> where
				F__: for<'owner> FnOnce(&'owner <$owner_ty as Deref>::Target) -> Result<$rental_ty, E__>
			{
				Ok($rental{
					rental: unsafe {
						let ptr: *const _ = &*<$owner_ty as Deref>::deref(&owner);
						match f(&*ptr) {
							Ok(asset) => Some(mem::transmute(asset)),
							Err(err) => return Err((err, owner)),
						}
					},
					owner: Some(owner),
				})
			}


			#[allow(dead_code)]
			pub fn owner(&self) -> &$owner_ty {
				self.owner.as_ref().unwrap()
			}


			#[allow(dead_code)]
			pub fn rent<'s, F__, R__>(&'s self, f: F__) -> R__ where
				F__: for<'owner: 's> FnOnce(&'s $rental_ty) -> R__, R__: 's
			{
				f(self.rental.as_ref().unwrap())
			}
		}


		unsafe impl<'owner $(, $param)*> Rental<'owner> for $rental<'owner $(, $param)*> where
			$owner_ty: FixedDeref,
			$($clause)*
		{
			type Owner = $owner_ty;
			type Rental = $rental_ty;


			#[inline(always)]
			unsafe fn rental(&self) -> &$rental_ty { self.rental.as_ref().unwrap() }
			unsafe fn from_parts(owner: $owner_ty, rent: $rental_ty) -> Self { $rental{owner: Some(owner), rental: Some(rent)} }
			unsafe fn into_parts(mut self) -> ($owner_ty, $rental_ty) { (self.owner.take().unwrap(), self.rental.take().unwrap()) }
			fn into_owner(mut self) -> $owner_ty { self.owner.take().unwrap() }
		}


		impl<'owner $(, $param)*> Deref for $rental<'owner $(, $param)*> where
			$owner_ty: FixedDeref,
			$rental<'owner $(, $param)*>: RentalDeref<'owner> + for<'rental> RentalDerefEq<'rental, $rental<'rental $(, $param)*>>,
		{
			type Target = <$rental<'owner $(, $param)*> as RentalDeref<'owner>>::Target;

			#[inline(always)]
			fn deref(&self) -> &<$rental<'owner $(, $param)*> as RentalDeref<'owner>>::Target { unsafe { self.rental_target() } }
		}


		impl<'rental $(, $param)*> Drop for $rental<'rental $(, $param)*> where
			$owner_ty: FixedDeref
		{
			fn drop(&mut self) {
				mem::drop(self.rental.take());
				mem::drop(self.owner.take());
			}
		}


		rental!{@ITEM $($rest)*}
	};


	{
		@ITEM pub mapper $mapper:ident<'owner $(, $param:tt)*>($($from_ty:tt)*) -> ($($into_ty:tt)*) where [$($clause:tt)*];
		$($rest:tt)*
	} => {
		#[allow(dead_code)]
		pub struct $mapper;
		impl $mapper {
			#[allow(dead_code)]
			pub fn map<'owner $(, $param)*, T__, U__, F__>(t: T__, f: F__) -> U__ where
				T__: Rental<'owner, Rental=$($from_ty)*>,
				U__: Rental<'owner, Owner=<T__ as Rental<'owner>>::Owner, Rental=$($into_ty)*>,
				F__: for<'rental: 'owner> FnOnce(rental_rebind!('rental {} $($from_ty)*)) -> rental_rebind!('rental {} $($into_ty)*),
				$($clause)*
			{
				unsafe { 
					let (o, r) = t.into_parts();
					U__::from_parts(o, f(r))
				}
			}


			#[allow(dead_code)]
			pub fn try_map<'owner $(, $param)*, T__, U__, E__, F__>(t: T__, f: F__) -> Result<U__, (E__, T__)> where
				T__: Rental<'owner, Rental=$($from_ty)*>,
				U__: Rental<'owner, Owner=<T__ as Rental<'owner>>::Owner, Rental=$($into_ty)*>,
				F__: for<'rental: 'owner> FnOnce(rental_rebind!('rental {} $($from_ty)*)) -> Result<rental_rebind!('rental {} $($into_ty)*), (E__, rental_rebind!('rental {} $($from_ty)*))>,
				$($clause)*
			{
				unsafe { 
					let (o, r) = t.into_parts();
					match f(r) {
						Ok(r) => Ok(U__::from_parts(o, r)),
						Err((e, r)) => Err((e, T__::from_parts(o, r))),
					}
				}
			}
		}


		rental!{@ITEM $($rest)*}
	};


	{
		@ITEM pub rental $rental:ident<'owner $(, $param:tt)*>($($body:tt)*); $($rest:tt)*
	} => {
		rental!{@ITEM pub rental $rental<'owner $(, $param)*> where [] ($($body)*); $($rest)*}
	};
	{
		@ITEM pub mapper $mapper:ident<'owner $(, $param:tt)*> ($($from_ty:tt)*) -> ($($into_ty:tt)*); $($rest:tt)*
	} => {
		rental!{@ITEM pub mapper $mapper<'owner $(, $param)*> ($($from_ty)*) -> ($($into_ty)*) where []; $($rest)*}
	};
	{ @ITEM } => { };
}


#[doc(hidden)]
#[macro_export]
macro_rules! rental_rebind {
	(
		$into:tt {$($head:tt)*} 'owner $($tail:tt)*
	) => {
		rental_rebind!($into {$($head)* $into} $($tail)*)
	};
	(
		$into:tt {$($head:tt)*} ($($inner:tt)*) $($tail:tt)*
	) => {
		rental_rebind!($into {($($head)*)} $($inner)* @> $($tail)*)
	};
	(
		$into:tt {$($head:tt)*} [$($inner:tt)*] $($tail:tt)*
	) => {
		rental_rebind!($into {[$($head)*]} $($inner)* @> $($tail)*)
	};
	(
		$into:tt {$($head:tt)*} {$($inner:tt)*} $($tail:tt)*
	) => {
		rental_rebind!($into {{$($head)*}} $($inner)* @> $($tail)*)
	};
	(
		$into:tt {($($head:tt)*) $($inner:tt)*} @> $($tail:tt)*
	) => {
		rental_rebind!($into {$($head)*($($inner)*)} $($tail)*)
	};
	(
		$into:tt {[$($head:tt)*] $($inner:tt)*} @> $($tail:tt)*
	) => {
		rental_rebind!($into {$($head)*[$($inner)*]} $($tail)*)
	};
	(
		$into:tt {{$($head:tt)*} $($inner:tt)*} @> $($tail:tt)*
	) => {
		rental_rebind!($into {$($head)*{$($inner)*}} $($tail)*)
	};
	(
		$into:tt {$($head:tt)*} $tok:tt $($tail:tt)*
	) => {
		rental_rebind!($into {$($head)* $tok} $($tail)*)
	};
	(
		$into:tt {$($rebound:tt)*}
	) => {
		$($rebound)*
	};
}


use std::ops::{Deref, DerefMut};
use std::{cell, rc, sync};


pub unsafe trait FixedDeref: Deref { }

unsafe impl<'t, T: ?Sized> FixedDeref for &'t T { }
unsafe impl<'t, T: ?Sized> FixedDeref for &'t mut T { }

unsafe impl<T: ?Sized> FixedDeref for Box<T> { }
unsafe impl<T> FixedDeref for Vec<T> { }
unsafe impl FixedDeref for String { }

unsafe impl<T: ?Sized> FixedDeref for rc::Rc<T> { }
unsafe impl<T: ?Sized> FixedDeref for sync::Arc<T> { }

unsafe impl<'t, T: ?Sized> FixedDeref for cell::Ref<'t, T> { }
unsafe impl<'t, T: ?Sized> FixedDeref for cell::RefMut<'t, T> { }
unsafe impl<'t, T: ?Sized> FixedDeref for sync::MutexGuard<'t, T> { }
unsafe impl<'t, T: ?Sized> FixedDeref for sync::RwLockReadGuard<'t, T> { }
unsafe impl<'t, T: ?Sized> FixedDeref for sync::RwLockWriteGuard<'t, T> { }


pub unsafe trait Rental<'rental> {
	type Owner: FixedDeref + 'rental;
	type Rental: 'rental;

	unsafe fn rental(&self) -> &<Self as Rental<'rental>>::Rental;
	unsafe fn from_parts(<Self as Rental<'rental>>::Owner, <Self as Rental<'rental>>::Rental) -> Self;
	unsafe fn into_parts(self) -> (<Self as Rental<'rental>>::Owner, <Self as Rental<'rental>>::Rental);
	fn into_owner(self) -> <Self as Rental<'rental>>::Owner;
}


pub unsafe trait RentalMut<'rental>: Rental<'rental> {
	unsafe fn rental_mut(&mut self) -> &mut <Self as Rental<'rental>>::Rental;
}


#[doc(hidden)]
pub unsafe trait RentalDeref<'rental> {
	type Target: ?Sized;

	unsafe fn rental_target<'s>(&'s self) -> &<Self as RentalDeref<'rental>>::Target where 'rental: 's;
}


#[doc(hidden)]
pub unsafe trait RentalDerefMut<'rental>: RentalDeref<'rental> {
	unsafe fn rental_target_mut<'s>(&'s mut self) -> &mut <Self as RentalDeref<'rental>>::Target where 'rental: 's;
}


#[doc(hidden)]
pub unsafe trait RentalDerefEq<'rental, U: RentalDeref<'rental>> { }


unsafe impl<'rental, T> RentalDeref<'rental> for T where
	T: Rental<'rental>, <T as Rental<'rental>>::Rental: Deref
{
	type Target = <<T as Rental<'rental>>::Rental as Deref>::Target;

	#[inline(always)]
	unsafe fn rental_target<'s>(&'s self) -> &<T as RentalDeref<'rental>>::Target where 'rental: 's { &**self.rental() }
}


unsafe impl<'rental, T> RentalDerefMut<'rental> for T where
	T: RentalMut<'rental> + RentalDeref<'rental, Target=<<T as Rental<'rental>>::Rental as Deref>::Target>,
	<T as Rental<'rental>>::Rental: DerefMut,
{
	#[inline(always)]
	unsafe fn rental_target_mut<'s>(&'s mut self) -> &mut <T as RentalDeref<'rental>>::Target where 'rental: 's { &mut **self.rental_mut() }
}


unsafe impl<'t, 'u, T, U> RentalDerefEq<'u, U> for T where
	T: RentalDeref<'t>,
	U: RentalDeref<'u, Target=<T as RentalDeref<'t>>::Target>,
{ }


rental! {
	mod premade {
		pub rental RentRef<'owner, T, B> where [T: FixedDeref + 'owner, B: 'owner] (T, &'owner B);
		pub rental RentMut<'owner, T, B> where [T: FixedDeref + DerefMut + 'owner, B: 'owner] (mut T, &'owner mut B);
		pub mapper MapRef<'owner, T, U>(&'owner T) -> (&'owner U) where [T: 'owner, U: 'owner];
		pub mapper MapMut<'owner, T, U>(&'owner mut T) -> (&'owner mut U) where [T: 'owner, U: 'owner];
	}
}


pub use premade::*;


pub type RentArc<'owner, T: 'owner, B: 'owner> = RentRef<'owner, sync::Arc<T>, B>;
pub type RentBox<'owner, T: 'owner, B: 'owner> = RentRef<'owner, Box<T>, B>;
pub type RentBoxMut<'owner, T: 'owner, B: 'owner> = RentMut<'owner, Box<T>, B>;
pub type RentMutex<'owner, T: 'owner, B: 'owner> = RentRef<'owner, sync::MutexGuard<'owner, T>, B>;
pub type RentMutexMut<'owner, T: 'owner, B: 'owner> = RentMut<'owner, sync::MutexGuard<'owner, T>, B>;
pub type RentRefCell<'owner, T: 'owner, B: 'owner> = RentRef<'owner, cell::Ref<'owner, T>, B>;
pub type RentRefCellMut<'owner, T: 'owner, B: 'owner> = RentMut<'owner, cell::RefMut<'owner, T>, B>;
pub type RentRwLock<'owner, T: 'owner, B: 'owner> = RentRef<'owner, sync::RwLockReadGuard<'owner, T>, B>;
pub type RentRwLockMut<'owner, T: 'owner, B: 'owner> = RentMut<'owner, sync::RwLockWriteGuard<'owner, T>, B>;
pub type RentString<'owner, B: 'owner> = RentRef<'owner, String, B>;
pub type RentStringMut<'owner, B: 'owner> = RentMut<'owner, String, B>;
pub type RentVec<'owner, T: 'owner, B: 'owner> = RentRef<'owner, Vec<T>, B>;
pub type RentVecMut<'owner, T: 'owner, B: 'owner> = RentMut<'owner, Vec<T>, B>;


#[cfg(test)]
mod test {
	use std::ops::{Deref, DerefMut};


	pub struct Foo<T> {
		val: T,
	}


	pub struct FooBorrow<'f, T: 'f> {
		val: &'f T,
		tag: i32,
	}


	pub struct FooBorrowMut<'f, T: 'f> {
		val: &'f mut T,
		tag: i32,
	}


	impl<T> Foo<T> {
		pub fn borrow(&self) -> FooBorrow<T> { FooBorrow{val: &self.val, tag: 1} }
		pub fn borrow_mut(&mut self) -> FooBorrowMut<T> { FooBorrowMut{val: &mut self.val, tag: 2} }
	}


	impl<'f, T> FooBorrow<'f, T> {
		pub fn frob(self) -> FooBorrow<'f, T> { self }
		pub fn try_frob(self) -> Result<FooBorrow<'f, T>, (String, FooBorrow<'f, T>)> { Ok(self) }
	}


	impl<'f, T> Deref for FooBorrow<'f, T> {
		type Target = T;

		fn deref(&self) -> &T { self.val }
	}


	impl<'f, T> Clone for FooBorrow<'f, T> {
		fn clone(&self) -> FooBorrow<'f, T> {
			FooBorrow{val: self.val, tag: self.tag}
		}
	}


	impl<'f, T> FooBorrowMut<'f, T> {
		pub fn frob(self) -> FooBorrowMut<'f, T> { self }
		pub fn fail_frob(self) -> Result<FooBorrowMut<'f, T>, (String, FooBorrowMut<'f, T>)> { Err(("Error".to_string(), self)) }
	}


	impl<'f, T> Deref for FooBorrowMut<'f, T> {
		type Target = T;

		fn deref(&self) -> &T { self.val }
	}


	impl<'f, T> DerefMut for FooBorrowMut<'f, T> {
		fn deref_mut(&mut self) -> &mut T { self.val }
	}


	rental!{
		mod test {
			pub rental Foo<'owner, T> where [T: 'owner] (Box<super::Foo<T>>, super::FooBorrow<'owner, T>);
			pub rental FooMut<'owner, T> where [T: 'owner] (mut Box<super::Foo<T>>, super::FooBorrowMut<'owner, T>);
			pub mapper MapFoo<'owner, T> (super::FooBorrow<'owner, T>) -> (super::FooBorrow<'owner, T>) where [T: 'owner];
			pub mapper MapFooMut<'owner, T> (super::FooBorrowMut<'owner, T>) -> (super::FooBorrowMut<'owner, T>) where [T: 'owner];
		}
	}


	#[test]
	fn new() {
		test::Foo::new(Box::new(Foo{val: 5}), |f| f.borrow());
	}


	#[test]
	fn new_mut() {
		test::FooMut::new(Box::new(Foo{val: 5}), |f| f.borrow_mut());
	}


	#[test]
	fn rent() {
		let foo = test::Foo::new(Box::new(Foo{val: 5}), |f| f.borrow());
		assert_eq!(foo.rent(|fb| **fb), 5);
	}


	#[test]
	fn rent_mut() {
		let mut foo = test::FooMut::new(Box::new(Foo{val: 5}), |f| f.borrow_mut());
		foo.rent_mut(|fbm| (*fbm.val) = 12);
		assert_eq!(foo.rent(|fbm| **fbm), 12);
	}


	#[test]
	fn rent_borrow() {
		let foo = test::Foo::new(Box::new(Foo{val: 5}), |f| f.borrow());
		let ft = foo.rent(|fb| &fb.tag);
		assert_eq!(*ft, 1);
	}


	#[test]
	fn rent_borrow_mut() {
		let mut foo = test::FooMut::new(Box::new(Foo{val: 5}), |f| f.borrow_mut());
		let ft = foo.rent_mut(|fbm| &mut fbm.tag);
		*ft = 3;
		assert_eq!(*ft, 3);
	}


	#[test]
	fn deref() {
		let foo = test::Foo::new(Box::new(Foo{val: 5}), |f| f.borrow());
		assert_eq!(*foo, 5);
	}


	#[test]
	fn deref_mut() {
		let mut foo_mut = test::FooMut::new(Box::new(Foo{val: 5}), |f| f.borrow_mut());
		*foo_mut = 12;
		assert_eq!(*foo_mut, 12);
	}


	#[test]
	fn map() {
		let mut foo = test::Foo::new(Box::new(Foo{val: 5}), |f| f.borrow());
		foo = test::MapFoo::map(foo, |b| b.frob());
		assert_eq!(*foo, 5);

		let mut foo_mut = test::FooMut::new(Box::new(Foo{val: 12}), |f| f.borrow_mut());
		foo_mut = test::MapFooMut::map(foo_mut, |b| b.frob());
		assert_eq!(*foo_mut, 12);
	}


	#[test]
	fn try_map() {
		let mut foo = test::Foo::new(Box::new(Foo{val: 5}), |f| f.borrow());
		foo = match test::MapFoo::try_map(foo, |b| b.try_frob()) {
			Ok(f) => f,
			Err((_, _)) => panic!(),
		};
		assert_eq!(*foo, 5);

		let mut _foo_mut = test::FooMut::new(Box::new(Foo{val: 12}), |f| f.borrow_mut());
		_foo_mut = match test::MapFooMut::try_map(_foo_mut, |b| b.fail_frob()) {
			Ok(f) => f,
			Err((e, f)) => {
				assert_eq!(e, "Error");
				assert_eq!(*f, 12);
				return;
			},
		};

		panic!();
	}
}
